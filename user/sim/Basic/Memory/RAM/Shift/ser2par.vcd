$date
   Wed Jun 19 20:33:37 2024
$end
$version
  2018.3
$end
$timescale
  1ps
$end
$scope module ser2par_tb $end
$var reg 1 ! clock $end
$var reg 1 " enable $end
$var reg 1 # reset $end
$var reg 1 $ ivalid $end
$var reg 1 % idata $end
$var wire 1 & ovalid $end
$var wire 8 ' odata [7:0] $end
$var wire 8 ( byte_out [7:0] $end
$var wire 1 ) output_valid $end
$scope module u_ser2par $end
$var wire 1 * clock $end
$var wire 1 + enable $end
$var wire 1 , reset $end
$var wire 1 - ivalid $end
$var wire 1 . idata $end
$var reg 1 / ovalid $end
$var reg 8 0 odata [7:0] $end
$var reg 8 1 data_buf [7:0] $end
$var reg 3 2 cnt [2:0] $end
$var parameter 32 3 LENGTH [31:0] $end
$upscope $end
$scope module u_bits_to_bytes $end
$var wire 1 4 clock $end
$var wire 1 5 enable $end
$var wire 1 6 reset $end
$var wire 1 7 bit_in $end
$var wire 1 8 input_valid $end
$var reg 8 9 byte_out [7:0] $end
$var reg 1 : output_valid $end
$var reg 8 ; bit_buf [7:0] $end
$var reg 3 < addr [2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0!
0"
1#
0$
0%
x&
bx '
bx (
x)
0*
0+
1,
0-
0.
x/
bx 0
bx 1
bx 2
b1000 3
04
05
16
07
08
bx 9
x:
bx ;
bx <
$end
#5000
1!
0&
b0 '
b0 (
0)
1*
0/
b0 0
b0 1
b0 2
14
b0 9
0:
b0 ;
b0 <
#10000
0!
1"
0#
1$
1%
0*
1+
0,
1-
1.
04
15
06
17
18
#15000
1!
1*
b10000000 1
b1 2
14
b10000000 ;
b1 <
#20000
0!
0%
0*
0.
04
07
#25000
1!
1*
b1000000 1
b10 2
14
b1000000 ;
b10 <
#30000
0!
1%
0*
1.
04
17
#35000
1!
1*
b10100000 1
b11 2
14
b10100000 ;
b11 <
#40000
0!
0%
0*
0.
04
07
#45000
1!
1*
b1010000 1
b100 2
14
b1010000 ;
b100 <
#50000
0!
1%
0*
1.
04
17
#55000
1!
1*
b10101000 1
b101 2
14
b10101000 ;
b101 <
#60000
0!
0%
0*
0.
04
07
#65000
1!
1*
b1010100 1
b110 2
14
b1010100 ;
b110 <
#70000
0!
1%
0*
1.
04
17
#75000
1!
1*
b10101010 1
b111 2
14
b10101010 ;
b111 <
#80000
0!
0*
04
#85000
1!
1&
b11010101 '
b11010101 (
1)
1*
1/
b11010101 0
b11010101 1
b0 2
14
b11010101 9
1:
b11010101 ;
b0 <
#90000
0!
0$
0*
0-
04
08
#95000
1!
0&
0)
1*
0/
14
0:
#100000
0!
0*
04
